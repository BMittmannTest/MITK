/*===================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center,
Division of Medical and Biological Informatics.
All rights reserved.

This software is distributed WITHOUT ANY WARRANTY; without
even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.

See LICENSE.txt or http://www.mitk.org for details.

===================================================================*/

#ifndef mitkRegionGrowingTool_h_Included
#define mitkRegionGrowingTool_h_Included

#include "mitkFeedbackContourTool.h"
#include "mitkLegacyAdaptors.h"
#include "SegmentationExports.h"

struct mitkIpPicDescriptor;

class ModuleResource;

namespace mitk
{

/**
  \brief A slice based region growing tool.

  \sa FeedbackContourTool

  \ingroup Interaction
  \ingroup ToolManagerEtAl

  When the user presses the mouse button, RegionGrowingTool will use the gray values at that position
  to initialize a region growing algorithm (in the affected 2D slice).

  By moving the mouse up and down while the button is still pressed, the user can change the parameters
  of the region growing algorithm (selecting more or less of an object).
  The current result of region growing will always be shown as a contour to the user.

  After releasing the button, the current result of the region growing algorithm will be written to the
  working image of this tool's ToolManager.

  If the first click is <i>inside</i> a segmentation that was generated by region growing (recently),
  the tool will try to cut off a part of the segmentation. For this reason a skeletonization of the segmentation
  is generated and the optimal cut point is determined.

  \warning Only to be instantiated by mitk::ToolManager.

  $Author$
*/
class Segmentation_EXPORT RegionGrowingTool : public FeedbackContourTool
{
  public:

    mitkClassMacro(RegionGrowingTool, FeedbackContourTool);
    itkNewMacro(RegionGrowingTool);

    virtual const char** GetXPM() const;
    virtual const char* GetName() const;
    virtual ModuleResource GetCursorIconResource() const;
    virtual ModuleResource GetIconResource() const;

  protected:

    RegionGrowingTool(); // purposely hidden
    virtual ~RegionGrowingTool();

    /**
      1 Determine which slice is clicked into
      2 Determine if the user clicked inside or outside of the segmentation
      3 Depending on the pixel value under the mouse click position, two different things happen: (separated out into OnMousePressedInside and OnMousePressedOutside)
       3.1 Create a skeletonization of the segmentation and try to find a nice cut
         3.1.1 Call a ipSegmentation algorithm to create a nice cut
         3.1.2 Set the result of this algorithm as the feedback contour
       3.2 Initialize region growing
         3.2.1 Determine memory offset inside the original image
         3.2.2 Determine initial region growing parameters from the level window settings of the image
         3.2.3 Perform a region growing (which generates a new feedback contour)
    */
    virtual bool OnMousePressed (Action*, const StateEvent*);
    /**
      3.1 Create a skeletonization of the segmentation and try to find a nice cut
      3.1.1 Call a ipSegmentation algorithm to create a nice cut
      3.1.2 Set the result of this algorithm as the feedback contour
    */
    virtual bool OnMousePressedInside (Action*, const StateEvent*, mitkIpPicDescriptor* workingPicSlice, int initialWorkingOffset);
    /**
     3.2 Initialize region growing
       3.2.1 Determine memory offset inside the original image
       3.2.2 Determine initial region growing parameters from the level window settings of the image
       3.2.3 Perform a region growing (which generates a new feedback contour)
    */
    virtual bool OnMousePressedOutside (Action*, const StateEvent*);
    /**
     If in region growing mode (m_ReferenceSlice != NULL), then
     1. Calculate the new thresholds from mouse position (relative to first position)
     2. Perform a new region growing and update the feedback contour
    */
    virtual bool OnMouseMoved   (Action*, const StateEvent*);
    /**
     If the feedback contour should be filled, then it is done here. (Contour is NOT filled, when skeletonization is done but no nice cut was found)
    */
    virtual bool OnMouseReleased(Action*, const StateEvent*);
    virtual bool OnChangeActiveLabel(Action*, const StateEvent*);
    /**
      Uses ipSegmentation algorithms to do the actual region growing. The result (binary image) is first smoothed by a 5x5 circle mask, then
      its contour is extracted and converted to MITK coordinates.
    */
    mitkIpPicDescriptor* PerformRegionGrowingAndUpdateContour(int timestep);

    Image::Pointer m_ReferenceSlice;
    Image::Pointer m_WorkingSlice;

    ScalarType m_LowerThreshold;
    ScalarType m_UpperThreshold;
    ScalarType m_InitialLowerThreshold;
    ScalarType m_InitialUpperThreshold;

    Point2I m_LastScreenPosition;
    int m_ScreenYDifference;

  private:

    /**
      Smoothes a binary ipPic image with a 5x5 mask. The image borders (some first and last rows) are treated differently.
    */
    mitkIpPicDescriptor* SmoothIPPicBinaryImage( mitkIpPicDescriptor* image, int &contourOfs, mitkIpPicDescriptor* dest = NULL );

    /**
      Helper method for SmoothIPPicBinaryImage. Smoothes a given part of and image.

      \param sourceImage The original binary image.
      \param dest The smoothed image (will be written without bounds checking).
      \param contourOfs One offset of the contour. Is updated if a pixel is changed (which might change the contour).
      \param maskOffsets Memory offsets that describe the smoothing mask.
      \param maskSize Entries of the mask.
      \param startOffset First pixel that should be smoothed using this mask.
      \param endOffset Last pixel that should be smoothed using this mask.
    */
    void SmoothIPPicBinaryImageHelperForRows( mitkIpPicDescriptor* source, mitkIpPicDescriptor* dest, int &contourOfs, int* maskOffsets, int maskSize, int startOffset, int endOffset );

    mitkIpPicDescriptor* m_OriginalPicSlice;
    int m_SeedPointMemoryOffset;

    ScalarType m_VisibleWindow;
    ScalarType m_DefaultWindow;
    ScalarType m_MouseDistanceScaleFactor;

    int m_PaintingPixelValue;
    int m_LastWorkingSeed;

    bool m_FillFeedbackContour;
};

} // namespace

#endif


